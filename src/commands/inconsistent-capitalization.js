import * as vscode from 'vscode'

/**
 * @param {vscode.ExtensionContext} context
 */
export function registerListInconsistentCapitalizationCommand (context) {
  context.subscriptions.push(vscode.commands.registerCommand('draftforge.listInconsistentCapitalization', async function () {
    try {
      const activeDoc = vscode.window.activeTextEditor.document

      const results = findInconsistentCapitalization(activeDoc.getText())

      const output = vscode.window.createOutputChannel('DraftForge')
      output.clear()
      output.appendLine(`List of inconsistent use of capitalization in ${activeDoc.fileName}:\n`)
      let idx = 0

      for (const key in results) {
        if (idx > 0) {
          output.appendLine('--------')
        }
        idx++
        const phrase = results[key]
        for (const variation of phrase) {
          output.appendLine(`${variation.text} (${variation.count})`)
        }
      }

      if (idx === 0) {
        output.appendLine('No inconsistent capitalization use found.')
        vscode.window.showInformationMessage('No inconsistent capitalization use found.')
      } else {
        vscode.window.showInformationMessage(`Found ${idx} inconsistent use of capitalization. See Output: DraftForge`)
      }

      output.show(true)
    } catch (err) {
      console.warn(err)
      vscode.window.showErrorMessage(err.message)
    }
  }))
}

/**
 * Finds inconsistent capitalization of 1-5 word sequences,
 * intelligently ignoring standard sentence-starting capitalization.
 * -> Generated by Google Gemini 3 Pro
 *
 * @param {string} text - The input text.
 * @return {Object} - Key: lowercase phrase, Value: Array of inconsistent variations.
 */
function findInconsistentCapitalization(text) {
  // 1. Pre-process: Tokenize and flag sentence starters
  // We match words OR sentence terminators.
  const rawTokens = text.match(/[a-zA-Z0-9']+|[.!?>]+/g) || [];

  const tokens = [];
  let nextIsStart = true; // First word is always start of sentence

  for (const t of rawTokens) {
    if (/^[.!?>]+$/.test(t)) {
      nextIsStart = true
    } else {
      tokens.push({ word: t, isStart: nextIsStart })
      nextIsStart = false
    }
  }

  // Map: lowercase_phrase -> Map<original_phrase, { hasStart: bool, hasMiddle: bool }>
  const phraseMap = new Map()
  const MIN_N = 2 // Minimum words (terms)
  const MAX_N = 5 // Maximum words (terms)

  // 2. Sliding Window
  for (let i = 0; i < tokens.length; i++) {
    let currentPhrase = ""
    let lowerPhrase = ""

    // The n-gram is considered a "start" n-gram if its FIRST word is a start word
    const isPhraseStart = tokens[i].isStart

    // Track if the sequence currently being built contains a 1-letter word
    let hasSingleLetterTerm = false;

    for (let j = 0; j < MAX_N && (i + j) < tokens.length; j++) {
      const tokenObj = tokens[i + j]
      const word = tokenObj.word;

      // CHECK: If any word in the sequence is 1 char (letter or number), flag it.
      if (word.length === 1) {
        hasSingleLetterTerm = true
      }

      // Build phrases
      if (j > 0) {
        currentPhrase += " " + tokenObj.word
        lowerPhrase += " " + tokenObj.word.toLowerCase()
      } else {
        currentPhrase = tokenObj.word
        lowerPhrase = tokenObj.word.toLowerCase()
      }

      // CHECK: Only store if we have reached the minimum word count (2+)
      // j is 0-indexed, so j=1 means 2 words.
      if (j >= MIN_N - 1&& !hasSingleLetterTerm) {
        if (!phraseMap.has(lowerPhrase)) {
          phraseMap.set(lowerPhrase, new Map())
        }

        const variations = phraseMap.get(lowerPhrase)
        if (!variations.has(currentPhrase)) {
          variations.set(currentPhrase, { hasStart: false, hasMiddle: false, count: 0 })
        }

        const stats = variations.get(currentPhrase)
        stats.count += 1
        if (isPhraseStart) {
          stats.hasStart = true
        } else {
          stats.hasMiddle = true
        }
      }
    }
  }

  // 3. Initial Filter (Grammar & Length)
  const results = {}

  for (const [key, variationMap] of phraseMap.entries()) {
    if (key.length <= 3) {
      continue
    }
    if (variationMap.size < 2) {
      continue
    }

    const validVariations = []
    for (const [phrase, stats] of variationMap.entries()) {

      const entry = { text: phrase, count: stats.count }

      if (stats.hasMiddle) {
        validVariations.push(entry)
      } else if (stats.hasStart) {
        // Check sentence case
        const sentenceCase = key.charAt(0).toUpperCase() + key.slice(1)
        if (phrase !== sentenceCase) {
          validVariations.push(entry)
        }
      }
    }

    if (validVariations.length > 1) {
      results[key] = validVariations
    }
  }

  // 4. Prune Subsets
  // If 'processing li' and 'processing li ul' both exist, remove 'processing li'
  const finalKeys = Object.keys(results)
  const keysToDelete = new Set()

  for (let i = 0; i < finalKeys.length; i++) {
    const shortKey = finalKeys[i]

    for (let j = 0; j < finalKeys.length; j++) {
      if (i === j) {
        continue // Don't compare self
      }

      const longKey = finalKeys[j]

      // If the short key is a substring of the long key, mark short key for deletion
      if (longKey.includes(shortKey)) {
        keysToDelete.add(shortKey)
        break // Found a containing parent, no need to check others
      }
    }
  }

  // Perform the deletion
  keysToDelete.forEach(k => delete results[k])

  return results
}
