import * as vscode from 'vscode'
import { repeat } from 'lodash-es'

/**
 * @param {vscode.ExtensionContext} context
 * @param {vscode.OutputChannel} outputChannel
 */
export function registerListInconsistentCapitalizationCommand (context, outputChannel) {
  context.subscriptions.push(vscode.commands.registerCommand('draftforge.listInconsistentCapitalization', async function () {
    try {
      const activeDoc = vscode.window.activeTextEditor?.document

      if (!activeDoc) {
        return vscode.window.showErrorMessage('Open a document first.')
      } else if (activeDoc.uri.scheme === 'output') {
        return vscode.window.showErrorMessage('Focus your desired document first. Focus is currently in the Output window.')
      } else if (!['xml', 'markdown', 'plaintext'].includes(activeDoc.languageId)) {
        return vscode.window.showErrorMessage('Unsupported Document Type.')
      }

      const ignoreTextRgx = /<name>(?<term>.+)<\/name>/gi
      const results = findInconsistentCapitalization(activeDoc.getText().replaceAll(ignoreTextRgx, (_, p1) => `<name>${repeat('_', p1.length)}</name>`))

      outputChannel.clear()
      outputChannel.appendLine(`List of inconsistent use of capitalization in ${activeDoc.fileName}:\n`)
      let idx = 0

      for (const key in results) {
        if (idx > 0) {
          outputChannel.appendLine('--------')
        }
        idx++
        const phrase = results[key]
        for (const variation of phrase) {
          outputChannel.appendLine(`${variation.text} (${variation.count}) (Ln ${variation.lines.join(', ')})`)
        }
      }

      if (idx === 0) {
        outputChannel.appendLine('No inconsistent capitalization use found.')
        vscode.window.showInformationMessage('No inconsistent capitalization use found.')
      } else {
        vscode.window.showInformationMessage(`Found ${idx} inconsistent use of capitalization. See Output: DraftForge`)
      }

      outputChannel.show(true)
    } catch (err) {
      console.warn(err)
      vscode.window.showErrorMessage(err.message)
    }
  }))
}

/**
 * Finds inconsistent capitalization of 1-5 word sequences,
 * intelligently ignoring standard sentence-starting capitalization.
 * -> Generated by Google Gemini 3 Pro
 *
 * @param {string} text - The input text.
 * @return {Object} - Key: lowercase phrase, Value: Array of objects { text, count, lines }
 */
function findInconsistentCapitalization(text) {
  // CONFIG: Words to ignore capitalization for (must be lowercase here)
  const IGNORED_TERMS = new Set([
    "the", "a", "an", "and", "but", "or", "nor", "for", "yet", "so", // Articles
    "in", "on", "at", "to", "of", "by", "with", "from", "up", "about", "into", "over", "after" // Prepositions
  ])

  // HELPER: check if two phrases are effectively the same ignoring preposition caps
  function isEffectivelySame(phrase1, phrase2) {
    const words1 = phrase1.split(" ")
    const words2 = phrase2.split(" ")

    if (words1.length !== words2.length) {
      return false
    }

    for (let i = 0; i < words1.length; i++) {
      const w1 = words1[i]
      const w2 = words2[i]

      // If the word is a preposition/article, we don't care about case match
      if (IGNORED_TERMS.has(w1.toLowerCase())) {
        if (w1.toLowerCase() !== w2.toLowerCase()) {
          return false
        }
      } else {
        // For distinct words (nouns, verbs), case MUST match exactly
        if (w1 !== w2) {
          return false
        }
      }
    }
    return true
  }

  // 1. Tokenize & Track Lines
  const rawLines = text.split(/\r?\n/)
  const tokens = []
  let nextIsStart = true

  rawLines.forEach((lineText, lineIndex) => {
    const lineTokens = lineText.match(/[a-zA-Z0-9']+|[.!?>]+/g) || []

    for (const t of lineTokens) {
      if (/^[.!?>]+$/.test(t)) {
        nextIsStart = true
      } else {
        tokens.push({
          word: t,
          isStart: nextIsStart,
          lineNumber: lineIndex + 1
        })
        nextIsStart = false
      }
    }
  })

  // Map: lowercase_key -> Array of raw variations found
  const phraseMap = new Map()
  const MIN_N = 2
  const MAX_N = 5

  // 2. Sliding Window
  for (let i = 0; i < tokens.length; i++) {
    let currentPhrase = ""
    let lowerPhrase = ""
    const isPhraseStart = tokens[i].isStart
    const startLine = tokens[i].lineNumber
    let hasSingleLetterTerm = false

    for (let j = 0; j < MAX_N && (i + j) < tokens.length; j++) {
      const tokenObj = tokens[i + j]
      const word = tokenObj.word

      // Flag single letters only if they are NOT in our ignored list
      if (word.length === 1 && !IGNORED_TERMS.has(word.toLowerCase())) {
        hasSingleLetterTerm = true
      }

      if (j > 0) {
        currentPhrase += " " + word
        lowerPhrase += " " + word.toLowerCase()
      } else {
        currentPhrase = word
        lowerPhrase = word.toLowerCase()
      }

      if (j >= MIN_N - 1 && !hasSingleLetterTerm) {
        if (!phraseMap.has(lowerPhrase)) {
          phraseMap.set(lowerPhrase, [])
        }

        phraseMap.get(lowerPhrase).push({
          text: currentPhrase,
          isStart: isPhraseStart,
          line: startLine
        })
      }
    }
  }

  // 3. Process & Filter Results
  const results = {}

  for (const [key, rawOccurrences] of phraseMap.entries()) {
    if (key.length <= 3) {
      continue
    }

    // Group effectively identical variations (ignoring prepositions)
    const uniqueVariations = []

    rawOccurrences.forEach(occ => {
      // Find if this specific text variation (handling ignored terms) already exists
      let match = uniqueVariations.find(v => isEffectivelySame(v.text, occ.text))

      if (!match) {
        match = {
          text: occ.text,
          count: 0,
          lines: [],
          hasStart: false,
          hasMiddle: false
        }
        uniqueVariations.push(match)
      }

      match.count++
      match.lines.push(occ.line)
      if (occ.isStart) {
        match.hasStart = true
      } else {
        match.hasMiddle = true
      }
    })

    // Skip if consistent (only 1 valid variation group found)
    if (uniqueVariations.length < 2) {
      continue
    }

    const validVariations = []
    for (const stats of uniqueVariations) {
      if (stats.hasMiddle) {
        validVariations.push({
          text: stats.text,
          count: stats.count,
          lines: stats.lines
        })
      } else if (stats.hasStart) {
        const sentenceCase = key.charAt(0).toUpperCase() + key.slice(1)
        if (!isEffectivelySame(stats.text, sentenceCase)) {
          validVariations.push({
            text: stats.text,
            count: stats.count,
            lines: stats.lines
          })
        }
      }
    }

    if (validVariations.length > 1) {
      results[key] = validVariations
    }
  }

  // 4. Prune Subsets
  const finalKeys = Object.keys(results)
  const keysToDelete = new Set()

  for (let i = 0; i < finalKeys.length; i++) {
    const shortKey = finalKeys[i]
    for (let j = 0; j < finalKeys.length; j++) {
      if (i === j) {
        continue
      }
      const longKey = finalKeys[j]
      if (longKey.includes(shortKey)) {
        keysToDelete.add(shortKey)
        break
      }
    }
  }

  keysToDelete.forEach(k => delete results[k])

  return results
}
