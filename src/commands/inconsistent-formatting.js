import * as vscode from 'vscode'

/**
 * @param {vscode.ExtensionContext} context
 */
export function registerListInconsistentFormattingCommand (context) {
  context.subscriptions.push(vscode.commands.registerCommand('draftforge.listInconsistentFormatting', async function () {
    try {
      const activeDoc = vscode.window.activeTextEditor.document

      const results = findInconsistentFormatting(activeDoc.getText(), activeDoc.languageId)

      const output = vscode.window.createOutputChannel('DraftForge')
      output.clear()
      output.appendLine(`List of inconsistent formatting in ${activeDoc.fileName}:\n`)
      let idx = 0

      for (const key in results) {
        if (idx > 0) {
          output.appendLine('--------')
        }
        idx++
        const phrase = results[key]
        for (const variation of phrase) {
          output.appendLine(`${variation.text} (${variation.count})`)
        }
      }

      if (idx === 0) {
        output.appendLine('No inconsistent formatting found.')
        vscode.window.showInformationMessage('No inconsistent formatting found.')
      } else {
        vscode.window.showInformationMessage(`Found ${idx} instance(s) of inconsistent formatting. See Output: DraftForge`)
      }

      output.show(true)
    } catch (err) {
      console.warn(err)
      vscode.window.showErrorMessage(err.message)
    }
  }))
}

/**
 * Find all instances of inconsistent formatting
 * -> Generated by Google Gemini 3 Pro
 *
 * @param {String} text
 * @param {String} languageId
 * @returns {Object}
 */
function findInconsistentFormatting (text, languageId) {
  const escapeRegExp = (s) => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
  const normalizedKeyOf = (s) => s.replace(/\s+/g, ' ').trim().toLowerCase()

  const formattedMatches = [] // { key, full, inner, start, end }

  const collectRegexMatches = (re, getInner) => {
    let m
    while ((m = re.exec(text)) !== null) {
      const full = m[0]
      const inner = getInner(m)
      const start = m.index
      const end = start + full.length
      const key = normalizedKeyOf(inner)
      if (!key) {
        continue
      }
      formattedMatches.push({ key, full, inner: inner.trim(), start, end })
    }
  }

  // detect xml tags
  if (languageId === 'xml') {
    const tagRe = /<(tt|em|strong|spanx)(?:\s[^>]*)?>([\s\S]*?)<\/\1\s*>/gi
    collectRegexMatches(tagRe, (m) => m[2] || '')
  }

  // detect markdown patterns
  if (/markdown|md/i.test(languageId)) {
    // bold **text**
    collectRegexMatches(/\*\*(.+?)\*\*/g, (m) => m[1])
    // italic *text* but not **bold**
    collectRegexMatches(/(^|[^*])\*([^*][\s\S]*?[^*])\*(?!\*)/g, (m) => m[2])
    // inline code `code`
    collectRegexMatches(/`([^`]+?)`/g, (m) => m[1])
  }

  // Build per-key variation counts from formatted matches
  const variationsByKey = {}
  for (const fm of formattedMatches) {
    const vmap = variationsByKey[fm.key] || (variationsByKey[fm.key] = {})
    vmap[fm.full] = (vmap[fm.full] || 0) + 1
  }

  // For each distinct key, find plain/unformatted occurrences
  const keys = Object.keys(variationsByKey)
  for (const key of keys) {
    // pick a representative inner text for searching (use first formatted match inner)
    const rep = formattedMatches.find(f => f.key === key)
    if (!rep) {
      continue
    }
    const searchRaw = rep.inner
    if (!searchRaw) {
      continue
    }
    const re = new RegExp(escapeRegExp(searchRaw), 'gi')
    let m
    while ((m = re.exec(text)) !== null) {
      const start = m.index
      // if this occurrence falls inside any formatted match range, skip (it's formatted)
      const insideFormatted = formattedMatches.some(f => start >= f.start && start < f.end)
      if (insideFormatted) {
        continue
      }
      const vmap = variationsByKey[key]
      const plainText = m[0]
      vmap[plainText] = (vmap[plainText] || 0) + 1
    }
  }

  // Convert to expected output shape and only return inconsistent ones (more than one variation)
  const results = {}
  for (const key in variationsByKey) {
    const vmap = variationsByKey[key]
    const variations = Object.keys(vmap).map(textVar => ({ text: textVar.trim(), count: vmap[textVar] }))
    if (variations.length > 1) {
      results[key] = variations
    }
  }

  return results
}
